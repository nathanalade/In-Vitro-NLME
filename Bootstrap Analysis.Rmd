---
title: "Bootstrap Analysis"
author: "Nathan Alade"
date: '2022-12-12'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Bootstrap Analysis

## Virtual Population Function

An updated version of a previous function `population.sim()` was generated called `population.sim2()`. The updated function provides greater flexibility substrate concentration range below 0.50 uM.  

```{r}
# ========== POPULATION SIMULATION FUNCTION =================#
## Updated to include low end point of 0.10 uM

population.sim2 <- function(
    
  # Pre-define number of subjects per diplotype group 
  n = 10,
  `CV%_D` = 25,
  `CV%_V` = 0,
  
  # Pre-define Michaelis Menten Kinetic Settings
  Start = 0.5, 
  End = 2000, 
  By = 0.5, 
  
  # Turn off or on use of true population frequency
  ## If set to true "n" will equal total population number
  pop_freq = FALSE,
  
  # Pre-define reference data, and set seed
  data = diplotype.data, 
  seed = 23457){
  
  # ======== Create Data Containers ========  
  
  datasets <- list()
  pop.data <- tibble()
  
  # ======== Create Datasets by Diplotype ========
  
  for (i in seq_along(data[[1]])){
    
    # Setting Population Specific Frequency
    n_pop <- if_else(pop_freq == FALSE, n, 
                     ifelse(pop_freq == TRUE, 
                            round(n*data[[i, c("Freq")]]), 0))
    
    # Specify Diplotype for current loop
    Diplotype = rep(data[[i,1]], n_pop)
    
    # Random assignment of Vmax values N(0,sigma)
    set.seed(seed)
    Vmax_eta <- rnorm(n_pop, sd = `CV%_D`)
    Vmax = data[[i,2]] + (Vmax_eta/100)*data[[i,2]]
    
    # Random assignment of Km values N(0,sigma)
    set.seed(seed)
    Km_eta <- rnorm(n_pop, sd = `CV%_D`)
    Km = data[[i,3]] + (Km_eta/100)*data[[i,3]]
    
    # Store each diplotype group in a list container
    temp <- tibble(Diplotype, Vmax, Km)
    datasets[[i]] <- temp
    
  }

  # ======== Combine Diplotype Datasets ========
  
  for (i in seq_along(data[[1]])){
    
    pop.data <- rbind(pop.data, datasets[[i]])
    
  }
  
  # ======== Simulate Michaelis Menten ========
  
  set.seed(seed)
  
  pop.data <- pop.data %>%  
    mutate(ID = factor(seq_along(Diplotype), 
                       levels = seq_along(Diplotype))) %>% 
    relocate(ID) %>% 
    expand_grid(S = c(0.1, seq(Start, End, By))) %>% 
    mutate(V = round((Vmax*S)/(Km+S), digits = 2))%>% 
    group_by(ID) %>% 
    
    # Additon of Residual Error
    mutate(resid_pct = round(rnorm(n = length(S),sd = `CV%_V`), 
                             digits = 3),
           V_adj = V+(V*resid_pct/100)) %>% 
    ungroup()
  
  
  return(pop.data)
  
}

```


## Generating Virtual Population (with Residual Error) 

Michaelis-Menten kinetics were simulated for each subject in the virtual population across the 4 experimental designs (0%, 5%, 10%, and 20% CV).

```{r}
# ========== CREATE BOOTSTRAP VIRTUAL POPULATIONS ============#

# Virtual Populations
CV0_virtual.pop <- population.sim2(n = 1000, `CV%_V` = 0, End = 2000)
CV5_virtual.pop <- population.sim2(n = 1000, `CV%_V` = 5, End = 2000)
CV10_virtual.pop <- population.sim2(n = 1000, `CV%_V` = 10, End = 2000)
CV20_virtual.pop <- population.sim2(n = 1000, `CV%_V` = 20, End = 2000)


# Sample Population Containers
CV0_Sample_populations = list()
CV5_Sample_populations = list()
CV10_Sample_populations = list()
CV20_Sample_populations = list()
```

## Bootstrap Sampling of Virtual Population

Using a `for()` loop, a total of 10 bootstrapped populations were generated for each experiental design (0-20% CV) by randomly sampling (with replacement) 1% of the corresponding virtual population (10 subject per genotype group, n = 90).  

```{r}
## Bootstrap for-loop
B = 10 ## number of bootstraps

for (i in 1:B) {

  # Bootstrap for 0% CV Population ---------
  CV0_Sample_populations[[i]] <- CV0_virtual.pop %>%
    group_by(Diplotype) %>%
    filter(ID %in% sample(ID, 10, replace = T)) %>%
    ungroup()

  # Bootstrap for 5% CV Population ---------
  CV5_Sample_populations[[i]] <- CV5_virtual.pop %>%
    group_by(Diplotype) %>%
    filter(ID %in% sample(ID, 10, replace = T)) %>%
    ungroup()

  # Bootstrap for 10% CV Population ---------
  CV10_Sample_populations[[i]] <- CV10_virtual.pop %>%
    group_by(Diplotype) %>%
    filter(ID %in% sample(ID, 10, replace = T)) %>%
    ungroup()

  # Bootstrap for 20% CV Population ---------
  CV20_Sample_populations[[i]] <- CV20_virtual.pop %>%
    group_by(Diplotype) %>%
    filter(ID %in% sample(ID, 10, replace = T)) %>%
    ungroup()

  }

# Combining Population Data -----------
Bootstrap.populations <- list(CV0_Sample_populations,
                              CV5_Sample_populations,
                              CV10_Sample_populations,
                              CV20_Sample_populations)

names(Bootstrap.populations)<- c("CV0_Pops",
                                 "CV5_Pops",
                                 "CV10_Pops",
                                 "CV20_Pops")

# saveRDS(Bootstrap.populations, "R Output/Bootsrap Populations Data.rds")
```


## Sampling Function

Strategic sampling designs were implemented using a custom function `update_pop()`, which functions similarly to the `update_data()` function mentioned previously, however, is designed to work more efficiently the `Bootstrap.populations` data which is a list of dataframes). The inputs for the `update_pop()` function include the following:

-   **pop_data** - A dataframe or indexed dataframe from a list of dataframes.

-   **type** - Specifies the strategic sampling design to be implemented. Options include: *"rich", "sparse3pt", "sparse4pt", "PM", "PM_3pt", "PM_4pt"*. 

---------------------------------------------------------------

```{r}

#======== CREATE BOOTSTRAP EXPERIMENTAL DATASETS =========#

# Function to transform virtual population into sample population

update_pop <-function(pop_data, type){
  
  # Sampling Information --------------
  # Full Range Set  
  full_set <- c(0.1, 0.5, 1, 2.5, 5, 10, 25, 50, 100)
  PM_range <- c(1, 5, 10, 15, 25, 30, 50, 60, 90, 100, 250, 500, 800, 1000, 1600, 2000)
  
  # Strategic Sampling Sets ----
  sparse3pt_set1 <- c(0.1, 2.5, 50)
  sparse3pt_set2 <- c(1, 10, 100)
  sparse4pt_set1 <- c(0.1, 2.5, 25, 50)
  sparse4pt_set2 <- c(1, 10, 50, 100)
  
  
  PM_3pt_set1 <- c(10,100,1000)
  PM_3pt_set2 <- c(25,250,2000)
  
  PM_4pt_set1 <- c(1,10,100,1000)
  PM_4pt_set2 <- c(5,25,250,2000)
  
  PM_range_set1 <- c(1,10,25,50,100,400,1000,2000)
  PM_range_set2 <- c(5,15,30,60,90,200,800,1600)
  
  ID_key <- pop_data %>% 
    select(Diplotype, ID) %>% 
    unique() %>% 
    group_by(Diplotype) %>% 
    mutate(n = 1:n()) %>% 
    ungroup()
  
  PM_Diplotype <- ID_key %>% 
    select(Diplotype) %>% 
    filter(Diplotype %in% c("4/5","4/41")) %>% 
    unique()
  
  EM_Diplotype <- ID_key %>% 
    select(Diplotype) %>% 
    filter(!Diplotype %in% c("4/5","4/41")) %>% 
    unique() 
  
  # Rich Sampling Simulation ----------------
  Data <- pop_data %>% 
    
    # Filter S Based on Experimental Model Type
    filter(S %in% switch(type,
                         "rich" = full_set, 
                         "sparse3pt" = full_set, 
                         "sparse4pt" = full_set,
                         "PM" = PM_range,
                         "PM_3pt" = PM_range,
                         "PM_4pt" = PM_range)) %>% 

    #Assign Sampling Key
    left_join(ID_key, by = c("Diplotype", "ID")) %>% 
    
    # Strategic Sampling
    mutate(Set = if_else(n %% 2 == 0, "Set 2", "Set 1")) %>%
    filter(if_else(Set == "Set 1",
                   S %in% switch(type,
                                 "rich" = full_set,
                                 "sparse3pt" = sparse3pt_set1,
                                 "sparse4pt" = sparse4pt_set1,
                                 "PM" = PM_range_set1,
                                 "PM_3pt" = PM_3pt_set1,
                                 "PM_4pt" = PM_4pt_set1),

                   S %in% switch(type,
                                 "rich" = full_set,
                                 "sparse3pt" = sparse3pt_set2,
                                 "sparse4pt" = sparse4pt_set2,
                                 "PM" = PM_range_set2,
                                 "PM_3pt" = PM_3pt_set2,
                                 "PM_4pt" = PM_4pt_set2))) %>%
    mutate(Diplotype = as_factor(Diplotype),
           V = round(V_adj, digits = 3)) %>%
    select(ID, Diplotype, S, V, Set) %>% 
    
    # Refine Inidvidual in dataset according to model
    filter(Diplotype %in% switch(type,
                         "rich" = EM_Diplotype[[1]], 
                         "sparse3pt" = EM_Diplotype[[1]], 
                         "sparse4pt" = EM_Diplotype[[1]],
                         "PM" = PM_Diplotype[[1]],
                         "PM_3pt" = PM_Diplotype[[1]],
                         "PM_4pt" = PM_Diplotype[[1]]))
  
  # Data Output ----------
  Data
    
}
```

## **In-Silico** Experiments (Rich and Strategic Sampling)

Using a `for()` loop, each virtual population was subject to all 3 sampling strategies (rich, sparse 3pt, and sparse 4pt); with sampling range varying according to CYP2D6 genotype as described previously (see *Strategic Sampling Approach*). Data was combined as a list of a list of dataframes with the first level (n = 4) being %CV specific data, the second level (n = 3) being sampling strategy with each variable at this level containing data for 10 unique population (n = 120 total datasets). 

---------------------------------------------------------------

```{r}
# Create Experimental Data sets Populations ---------

CV0_Boot.data <- list()
CV5_Boot.data <- list()
CV10_Boot.data <- list()
CV20_Boot.data <- list()

# For Loop to apply strategic sampling to all dataframes ----------
for (i in 1:B) {
    
  CV0_Boot.data$rich[[i]] <- update_pop(Bootstrap.populations$CV0_Pops[[i]], type = "rich")
  CV0_Boot.data$sparse3pt[[i]] <- update_pop(Bootstrap.populations$CV0_Pops[[i]], type = "sparse3pt")
  CV0_Boot.data$sparse4pt[[i]] <- update_pop(Bootstrap.populations$CV0_Pops[[i]], type = "sparse4pt")
  CV0_Boot.data$PM[[i]] <- update_pop(Bootstrap.populations$CV0_Pops[[i]], type = "PM")
  CV0_Boot.data$PM_3pt[[i]] <- update_pop(Bootstrap.populations$CV0_Pops[[i]], type = "PM_3pt")
  CV0_Boot.data$PM_4pt[[i]] <- update_pop(Bootstrap.populations$CV0_Pops[[i]], type = "PM_4pt")
  
  cat('CV0 Iteration', i, "of", B, "complete...\n")
  
  CV5_Boot.data$rich[[i]] <- update_pop(Bootstrap.populations$CV5_Pops[[i]], type = "rich")
  CV5_Boot.data$sparse3pt[[i]] <- update_pop(Bootstrap.populations$CV5_Pops[[i]], type = "sparse3pt")
  CV5_Boot.data$sparse4pt[[i]] <- update_pop(Bootstrap.populations$CV5_Pops[[i]], type = "sparse4pt")
  CV5_Boot.data$PM[[i]] <- update_pop(Bootstrap.populations$CV5_Pops[[i]], type = "PM")
  CV5_Boot.data$PM_3pt[[i]] <- update_pop(Bootstrap.populations$CV5_Pops[[i]], type = "PM_3pt")
  CV5_Boot.data$PM_4pt[[i]] <- update_pop(Bootstrap.populations$CV5_Pops[[i]], type = "PM_4pt")
  
  cat('CV5 Iteration', i, "of", B, "complete...\n")
    
  CV10_Boot.data$rich[[i]] <- update_pop(Bootstrap.populations$CV10_Pops[[i]], type = "rich")
  CV10_Boot.data$sparse3pt[[i]] <- update_pop(Bootstrap.populations$CV10_Pops[[i]], type = "sparse3pt")
  CV10_Boot.data$sparse4pt[[i]] <- update_pop(Bootstrap.populations$CV10_Pops[[i]], type = "sparse4pt")
  CV10_Boot.data$PM[[i]] <- update_pop(Bootstrap.populations$CV10_Pops[[i]], type = "PM")
  CV10_Boot.data$PM_3pt[[i]] <- update_pop(Bootstrap.populations$CV10_Pops[[i]], type = "PM_3pt")
  CV10_Boot.data$PM_4pt[[i]] <- update_pop(Bootstrap.populations$CV10_Pops[[i]], type = "PM_4pt")
  
  cat('CV10 Iteration', i, "of", B, "complete...\n")
  
  CV20_Boot.data$rich[[i]] <- update_pop(Bootstrap.populations$CV20_Pops[[i]], type = "rich")
  CV20_Boot.data$sparse3pt[[i]] <- update_pop(Bootstrap.populations$CV20_Pops[[i]], type = "sparse3pt")
  CV20_Boot.data$sparse4pt[[i]] <- update_pop(Bootstrap.populations$CV20_Pops[[i]], type = "sparse4pt")
  CV20_Boot.data$PM[[i]] <- update_pop(Bootstrap.populations$CV20_Pops[[i]], type = "PM")
  CV20_Boot.data$PM_3pt[[i]] <- update_pop(Bootstrap.populations$CV20_Pops[[i]], type = "PM_3pt")
  CV20_Boot.data$PM_4pt[[i]] <- update_pop(Bootstrap.populations$CV20_Pops[[i]], type = "PM_4pt")
  
  cat('CV20 Iteration', i, "of", B, "complete...\n")
  
}

# Combine all boostrap data into a single data structure ---------
Complete_Bootstrap.data <- list(CV0_Boot.data,
                          CV5_Boot.data,
                          CV10_Boot.data,
                          CV20_Boot.data)

names(Complete_Bootstrap.data) <-c("CV0","CV5","CV10","CV20")

# Save the completed bootstrap data sets ------
# saveRDS(Complete_Bootstrap.data, "R Output/Complete Bootstrap Data.rds")

```


## NLME Fitting Function

`fit_nlme()` is a custom function used to simultaneously fit non-linear least squares, and non-linear mixed effect models (with and without covariates). The inputs for the function include the following:

-   **data** - Data to be used for model fitting

-   **type** - Type of CYP2D6 metabolizer. Options include: *"EM"* for extensive metabolizer and ultra-rapid metabolizer data, and *"PM"* for intermediate and poor metabolizer data (default = "EM"). 

-   **which** - Specifies the desired model output. Options include: *"nls"* = non-linear least squares, *"base.model"* for NLME with out covariates, *"covar.model"* for NLME with covariates (CYP2D6 genotype); default = "covar.model". 

---------------------------------------------------------------

```{r}

# ==== Fitting Mixed Effect Model ================#

fit_nlme <- function(data, type = "EM", which = "covar.model"){

n <- if_else(type == "PM", 1, 6)
  
# Initial Screen ----  
data0.grp <- groupedData(V~S|ID, data)
fit0.nls <- nlsList(V~SSmicmen(S,Vmax,Km), data = data0.grp)

# Extract Erroneous Subjects
error.vmax <- coef(fit0.nls) %>%
  filter(is.na(Vmax)) %>%
  row.names() %>%
  as.numeric()

error.km <- coef(fit0.nls) %>%
  filter(is.na(Km)) %>%
  row.names() %>%
  as.numeric()

error.list <- c(error.vmax, error.km)

# Clean Data set
data.grp <- data0.grp %>% filter(!ID %in% error.list)

# Base Model Fits
fit.nls <- nlsList(V~SSmicmen(S,Vmax,Km), data = data.grp)

base.nlme <- nlme(fit.nls, random = pdDiag(Vmax + Km ~ 1))
covar.nlme <- update(base.nlme, fixed = Vmax + Km ~ Diplotype, 
                          start = c(fixef(base.nlme)[[1]], rep(0,n), 
                                    fixef(base.nlme)[[2]], rep(0,n)),
                     weights = varPower())

# Output ----------
switch (which,
  "nls" = fit.nls,
  "base.model" = base.nlme,
  "covar.model" = covar.nlme)

}
```


## NLME Estimate Extraction Function

`extract_nlme_est()` is a custom function used to fit, extract, and tidy NLME parameter estimates from experimental data.  This function is optimized to work within the context of a `for()` loop, and contains the `fit_nlme()` function as a dependency. The inputs for the function include the following:

-   **exp.data** - Experimental data that NLME estimates are desired from.

-   **condition** - Label used to tag experimental condition from which the experimental data belongs.

-   **PM** - TRUE or FALSE argument specifying where data belongs to IM/PM CYP2D6 genotype (TRUE), or UM/EM CYP2D6 genotype (FALSE); default = "FALSE".

-   **pop.num** - Label specifying which bootstrapped population is being analyzed (default = 1). 

---------------------------------------------------------------

```{r}

extract_nlme_est <- function(exp.data, condition, PM = FALSE, pop.num = 1){
  
  # Input ----------
  model.type <- if_else(PM == TRUE, "PM", "EM")
  nlme.model <- fit_nlme(exp.data, type = model.type)
  int.data <- intervals(nlme.model, which = "fixed")
  label <- if_else(PM == TRUE, "4/41", "1/1")
  
  # Tidy Data -------
  temp <- int.data$fixed %>%
    as_tibble() %>% 
    mutate(Parameter = rownames(int.data$fixed)) %>% 
    separate(Parameter, remove = T, sep = "\\.", into = c("Parameter", "Diplotype"))%>% 
    mutate(Diplotype = recode(Diplotype, "(Intercept)" = paste0("Diplotype",label))) %>%
    group_by(Parameter) %>%
    mutate(est. = if_else(Diplotype != paste0("Diplotype",label),
                          est. + est.[Diplotype == paste0("Diplotype",label)],
                          est.),
           across(where(is.numeric), round, 2)) %>% 
    ungroup() %>% 
    separate(Diplotype, remove = T, sep = "Diplotype", into = c(".", "Diplotype"))%>% 
    select(Parameter, Diplotype, est.)
  
  colnames(temp) <- c("Parameter", "Diplotype", paste(condition))
  
  # Output ----
  temp %>% 
    pivot_longer( 3, names_to = "Condition", values_to = "Estimate") %>% 
    mutate(Population = pop.num)
  
}


extract_nlme_est(exp.data = Complete_Bootstrap.data$CV0$sparse3pt[[3]], 
                 condition = "Sparse (3pt, CV 5%)", PM = FALSE, pop.num = 3)

```


## Non-Linear Mixed Effect Modeling (Bootstrap Populations)

Using a `for()` loop, bootstrapped parameter estimates were extracted from experimental data (`Complete_Bootstrap.data`) using the `extract_nlme.est()` function. Parameter estimate for all experimental designs and conditions for each population were stored in object `Complete_Bootstrap.est` as a list. A collapsed version was saved as `Complete Bootstrap table.RDS` for data analysis and user reproducibility purposes. 

```{r}

Complete_Bootstrap.est <- list()

for (i in 1:B) {
  
  
  # CV 0% Condition -------------  
  CV0_est.table <- rbind(
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV0$rich[[i]],
                   condition = "Rich (CV 0%)", pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV0$sparse3pt[[i]],
                   condition = "Sparse (3pt, CV 0%)", pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV0$sparse4pt[[i]],
                   condition = "Sparse (4pt, CV 0%)", pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV0$PM[[i]],
                   condition = "Rich (CV 0%)", PM = TRUE, pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV0$PM_3pt[[i]],
                   condition = "Sparse (3pt, CV 0%)", PM = TRUE, pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV0$PM_4pt[[i]],
                   condition = "Sparse (4pt, CV 0%)", PM = TRUE, pop.num = i))

  cat('CV0% - Iteration', i, "of", B, "complete...\n")
   
  # # # CV 5% Condition -------------
  CV5_est.table <- rbind(
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV5$rich[[i]],
                   condition = "Rich (CV 5%)", pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV5$sparse3pt[[i]],
                   condition = "Sparse (3pt, CV 5%)", pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV5$sparse4pt[[i]],
                   condition = "Sparse (4pt, CV 5%)", pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV5$PM[[i]],
                   condition = "Rich (CV 5%)", PM = TRUE, pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV5$PM_3pt[[i]],
                   condition = "Sparse (3pt, CV 5%)", PM = TRUE, pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV5$PM_4pt[[i]],
                   condition = "Sparse (4pt, CV 5%)", PM = TRUE, pop.num = i))

  cat('CV5% - Iteration', i, "of", B, "complete...\n")
  
  # # CV 10% Condition -------------
  CV10_est.table <- rbind(
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV10$rich[[i]],
                   condition = "Rich (CV 10%)", pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV10$sparse3pt[[i]],
                   condition = "Sparse (3pt, CV 10%)", pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV10$sparse4pt[[i]],
                   condition = "Sparse (4pt, CV 10%)", pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV10$PM[[i]],
                   condition = "Rich (CV 10%)", PM = TRUE, pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV10$PM_3pt[[i]],
                   condition = "Sparse (3pt, CV 10%)", PM = TRUE, pop.num = i),
  extract_nlme_est(exp.data = Complete_Bootstrap.data$CV10$PM_4pt[[i]],
                   condition = "Sparse (4pt, CV 10%)", PM = TRUE, pop.num = i))

  cat('CV10% - Iteration', i, "of", B, "complete...\n")

  # CV 20% Condition -------------
# Problematic fails to converge, requires further attention ##

CV20_est.table <- rbind(
extract_nlme_est(exp.data = Complete_Bootstrap.data$CV20$rich[[i]],
                 condition = "Rich (CV 20%)", pop.num = i),
extract_nlme_est(exp.data = Complete_Bootstrap.data$CV20$sparse3pt[[i]],
                 condition = "Sparse (3pt, CV 20%)", pop.num = i),
extract_nlme_est(exp.data = Complete_Bootstrap.data$CV20$sparse4pt[[i]],
                 condition = "Sparse (4pt, CV 20%)", pop.num = i),
extract_nlme_est(exp.data = Complete_Bootstrap.data$CV20$PM[[i]],
                 condition = "Rich (CV 20%)", PM = TRUE, pop.num = i),
extract_nlme_est(exp.data = Complete_Bootstrap.data$CV20$PM_3pt[[i]],
                 condition = "Sparse (3pt, CV 20%)", PM = TRUE, pop.num = i),
extract_nlme_est(exp.data = Complete_Bootstrap.data$CV20$PM_4pt[[i]],
                 condition = "Sparse (4pt, CV 20%)", PM = TRUE, pop.num = i))

cat('CV20% - Iteration', i, "of", B, "complete...\n")

  Complete_Bootstrap.est[[i]] <- rbind(CV0_est.table,
                                       CV5_est.table,
                                       CV10_est.table,
                                       CV20_est.table)

  # Progress Report -------
  cat('==== ROUND', i, "of", B, "COMPLETE! ===\n")
  
  }


Complete_Bootstrap.table <- bind_rows(Complete_Bootstrap.est)

# saveRDS(R Output/Complete Bootstrap Table.rds")

```

